
## 参考 
[常见数据结构和Javascript实现总结](https://segmentfault.com/a/1190000020011987#item-4)  
[树的高度和深度以及结点的高度和深度](https://blog.csdn.net/qq_36667170/article/details/84142019)  
## 队列
```js
let Queue = function() {
    // data 是存储元素的数组
    this.data = []
}

// 入队
Queue.prototype.enqueue = function (element) {
    this.data.push(element)
}

// 出队
Queue.prototype.dequeue = function () {
    return this.data.splice(0, 1)
}

// 队列长度
Queue.prototype.length = function () {
    return this.data.length
}

// 清空队列
Queue.prototype.empty = function() {
    this.data = []
}

// 测试
// let q = new Queue()
// q.enqueue(1)
// q.enqueue(2)
// q.enqueue(3)
// log('length', q.length())
// log(q.dequeue())
// q.enqueue(4)
// log(q.dequeue())
// log(q.dequeue())
// log(q.dequeue())
```


## Stack 栈
```js
// 常见的 3 个操作：push pop top
let Stack = function() {
    this.data = []

// push 添加一个元素
Stack.prototype.push = function(e) {
    this.data.push(e)
}

// pop 删除并返回最新添加的元素
Stack.prototype.pop = function() {
    let index = this.data.length - 1
    return this.data.splice(index, 1)
}

// top 仅返回最新添加的元素
Stack.prototype.top = function() {
    let index = this.data.length - 1
    return this.data[index]
}

// test
/*
let s = new Stack()
s.push('hello')
s.push('world')
log(s.pop())
log(s.pop())

let str = 'hello'
for (let i = 0; i < str.length; i++) {
    s.push(str[i])
}

let str1 = ''
for (let i = 0; i < str.length; i++) {
    str1 += s.pop(str[i])
}
log(str1)
*/
```


## 链表
```js
// 链表实现
let Node = function(e) {
    this.element = e
    this.next = null
}

// test
/*
let n1 = new Node(1)
let n2 = new Node(2)
let n3 = new Node(3)
n1.next = n2
n2.next = n3

let n = n1
while(n != null) {
    log('遍历链表', n.element)
    n = n.next
}
*/

let LinkedList = function() {
    this.head = new Node()
    this._length = 0
}

// 在链表末尾 增加一个元素
LinkedList.prototype.append = function(e) {
    let node = new Node(e)
    let n = this.head
    while(n.next != null) {
        n = n.next
    }
    n.next = node
    //
    this._length++
}

// 返回一个元素的 index
LinkedList.prototype.indexOf = function(e) {
    let index = -1
    let n = this.head
    let i = 0
    while(n.next != null) {
        if (e === n.element) {
            index = i
            break
        }
        n = n.next
        i++
    }
    return index
}

// 返回链表的长度
LinkedList.prototype.length = function() {
    return this._length
}

LinkedList.prototype.log = function() {
    let n = this.head.next
    log('遍历链表')
    while(n != null) {
        log(' > ', n.element)
        n = n.next
    }
}

// test
/*
let list = new LinkedList()
list.append('hello')
list.append('gua')
list.append('你好')
list.log()
log(list.length())
*/
```




## 其他数据结构
```js
/*
hash table  哈希表（散列表）
tree        树
set         集合
graph       图


哈希表就是用 字符串 当下标，也就是 js 中的对象的实现方式
也就是其他语言中的 字典

原理是用字符串 算出一个数字 然后用这个数字当下标存东西
比如 gua 这个字符串 我们用每个字符乘以一个数字最后求余得到下标
从字符串到数字的操作叫做 hash
// hash('gua') = 1
// hash('hs') = 3
【坑1， 坑2， 坑3， 坑4， 坑5， 坑6】
  gua       hs              wh
  xiao      lj
            bl



树一般是用来实现二叉搜索树的，应用范围不多
     6
    / \
   4   8
    \ / \
    57  9
    
*/
```

## 集合 Set
Set 中的元素 `不重复`、`无序`  

### 常见方法
-    values： 返回集合中的所有元素
-    size： 返回集合中元素的个数
-    has： 判断集合中是否存在某个元素
-    add： 向集合中添加元素
-    remove： 从集合中移除某个元素
-    union： 返回两个集合的并集
-    intersection： 返回两个集合的交集
-    difference： 返回两个集合的差集
-    subset： 判断一个集合是否为另一个集合的子集

```js
function MySet() {
  let collection = [];
  this.has = function (element) {
    // 如果不存在，则返回-1
    return (collection.indexOf(element) !== -1);
  }

  this.values = function () {
    return collection;
  }

  this.size = function () {
    return collection.length;
  }

  this.add = function (element) {
    if (!this.has(element)) {
      collection.push(element);
      return true;
    }
    return false;
  }

  this.remove = function (element) {
    if (this.has(element)) {
      index = collection.indexOf(element);
      collection.splice(index, 1);
      return true;
    }
    return false;
  }

  this.union = function (otherSet) {
    let unionSet = new MySet();
    let firstSet = this.values();
    let secondSet = otherSet.values();
    firstSet.forEach(function (e) {
      unionSet.add(e);
    });
    secondSet.forEach(function (e) {
      unionSet.add(e);
    });
    return unionSet;
  }

  this.intersection = function (otherSet) {
    let intersectionSet = new MySet();
    let firstSet = this.values();
    firstSet.forEach(function (e) {
      if (otherSet.has(e)) {
        intersectionSet.add(e);
      }
    });
    return intersectionSet;
  }

  this.difference = function (otherSet) {
    let differenceSet = new MySet();
    let firstSet = this.values();
    firstSet.forEach(function (e) {
      if (!otherSet.has(e)) {
        differenceSet.add(e);
      }
    });
    return differenceSet;
  }

  this.subset = function (otherSet) {
    let firstSet = this.values();
    return firstSet.every(function (value) {
      return otherSet.has(value);
    });
  }
}
```


## Hash Table（哈希表/散列表）
Hash Table内部使用一个hash函数将传入的键转换成一串数字，而这串数字将作为键值对实际的key 

### 常见方法
-    add： 增加一组键值对
-    remove： 删除一组键值对
-    lookup： 查找一个键对应的值


```js
function hash(string, max) {
  let hash = 0;
  for (let i = 0; i < string.length; i++) {
    hash += string.charCodeAt(i);
  }
  return hash % max;
}

function HashTable() {
  let storage = [];
  const storageLimit = 4;

  this.add = function (key, value) {
    let index = hash(key, storageLimit);
    if (storage[index] === undefined) {
      storage[index] = [
        [key, value]
      ];
    } else {
      let inserted = false;
      for (let i = 0; i < storage[index].length; i++) {
        if (storage[index][i][0] === key) {
          storage[index][i][1] = value;
          inserted = true;
        }
      }
      if (inserted === false) {
        storage[index].push([key, value]);
      }
    }
  }

  this.remove = function (key) {
    let index = hash(key, storageLimit);
    if (storage[index].length === 1 && storage[index][0][0] === key) {
      delete storage[index];
    } else {
      for (let i = 0; i < storage[index]; i++) {
        if (storage[index][i][0] === key) {
          delete storage[index][i];
        }
      }
    }
  }

  this.lookup = function (key) {
    let index = hash(key, storageLimit);
    if (storage[index] === undefined) {
      return undefined;
    } else {
      for (let i = 0; i < storage[index].length; i++) {
        if (storage[index][i][0] === key) {
          return storage[index][i][1];
        }
      }
    }
  }
}
```

## 树
### 相关概念
-    Leaf（叶节点）：没有子节点的节点
-    Edge（边）：两个节点之间的连接线
-    Path（路径）：从源节点到目标节点的连续边
-    Degree of Node（节点的度）：表示拥有的子节点的个数
-    Height of Tree（树的高度）：也即深度，即树的最大层数（根节点层数从1开始，从0需减1层）
-    Height of Node（节点的高度）：该节点树内的叶节点的最大层数。叶节点高度为 1，往上节点的高度递增。一个节点的高度取最大值
-    Depth of Node（节点的深度）：从根节点到该节点的层数

`层数一般从1开始`

#### 树节点的高度

![树节点的高度](https://github.com/LahmYing/front-end-tools/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E8%8A%82%E7%82%B9%E9%AB%98%E5%BA%A6.jpg) 

## 二叉查找树
每个节点最多只有两个子节点  
左侧子节点 < 当前节点  
右侧子节点 > 当前节点  



