## 参考
[JavaScript中常见的十五种设计模式（上）](https://zhuanlan.zhihu.com/p/46066237)

## 单例模式

#### 定义
保证一个类仅有一个实例，并提供一个访问它的全局访问点

```js
// 实现方式
// 比如可以使用闭包缓存一个内部变量来实现这个单例
function SetManager(name) {
    this.manager = name;
}

SetManager.prototype.getName = function() {
    console.log(this.manager);
};
// 后续写法 1
// let SingletonSetManager = (function() {
//     let manager = null;
//     // 内部变量保存类的实例，存在则继续沿用这个实例
//     return function(name) { // 传参给闭包函数 SingletonSetManager 的 name，其实是传给其 return 的函数
//         if (!manager) {
//             manager = new SetManager(name);
//         }
//         return manager;
//     } 
// })();
// SingletonSetManager('a').getName(); // a
// SingletonSetManager('b').getName(); // a
// SingletonSetManager('c').getName(); // a

// 后续写法 2
// 提取出通用的单例
function getSingleton(fn) {
    let instance = null;

    return function() {
        if (!instance) {
            instance = fn.apply(this, arguments); // 等于 this.fn(arguments)
            console.log('arguments:  ' + JSON.stringify(arguments)); // arguments 直接可打印出来
        }

        return instance;
    }
}

// 获取单例
let managerSingleton = getSingleton(function(name) {
    let manager = new SetManager(name);
    return manager;
});

managerSingleton('a').getName(); // a
managerSingleton('b').getName(); // a
managerSingleton('c').getName(); // a
```

## 策略模式

#### 定义

定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

#### 分离

**使用** ← 分离 → **实现**

#### 组成

- 一组策略类，封装具体算法，负责具体计算

- 环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类

```js
// eg：表单的验证方法

// 错误提示
let errorMsgs = {
    default: '输入数据格式不正确',
    minLength: '输入数据长度不足',
    isNumber: '请输入数字',
    required: '内容不为空'
};

// 规则集
let rules = {
    minLength: function(value, length, errorMsg) {
        if (value.length < length) {
            return errorMsg || errorMsgs['minLength']
        }
    },
    isNumber: function(value, errorMsg) {
        if (!/\d+/.test(value)) {
            return errorMsg || errorMsgs['isNumber'];
        }
    },
    required: function(value, errorMsg) {
        if (value === '') {
            return errorMsg || errorMsgs['required'];
        }
    }
};

// 校验器
function Validator() {
    this.items = [];
};

Validator.prototype = {
    constructor: Validator,
    
    // 添加校验规则
    add: function(value, rule, errorMsg) {
        let arg = [value];

        if (rule.indexOf('minLength') !== -1) {
            let temp = rule.split(':');
            arg.push(temp[1]);
            rule = temp[0];
        }

        arg.push(errorMsg);

        this.items.push(function() {
            // 进行校验
            return rules[rule].apply(this, arg);
        });
    },
    
    // 开始校验
    start: function() {
        for (let i = 0; i < this.items.length; ++i) {
            let ret = this.items[i]();
            
            if (ret) {
                console.log(ret);
                // return ret;
            }
        }
    }
};

// 测试数据
function testTel(val) {
    return val;
}

let validate = new Validator();

validate.add(testTel('ccc'), 'isNumber', '只能为数字'); // 只能为数字
validate.add(testTel(''), 'required'); // 内容不为空
validate.add(testTel('123'), 'minLength:5', '最少5位'); // 最少5位
validate.add(testTel('12345'), 'minLength:5', '最少5位');

let ret = validate.start();

console.log(ret);
```

## 代理模式

- 保护代理

- 虚拟代理

 - 在控制对主体的访问时，加入了一些额外的操作

- 缓存代理

```js
// 虚拟代理
  /**
   * 函数节流： 
   * mustRunDelay 时间内重复执行【延迟 delay 时间执行 fn】,到达 mustRunDelay 时间长度则马上执行 fn
   * eg: window.onscroll = throttle(fn, delay, mustRunDelay)
   * @param fn  函数
   * @param delay 多久执行一次
   * @param mustRunDelay 执行时间间隔
   * @return {Function}
   */
  throttle(fn, delay, mustRunDelay) {
    /*eslint-disable*/
    let timer = null
    let t_start
    return function () {
      let context = this, args = arguments, t_curr = +new Date()
      // 清除定时操作
      clearTimeout(timer)
      if (!t_start) {
        t_start = t_curr
      }
      // 时间间隔超过 mustRunDelay 则马上执行 fn
      if (t_curr - t_start >= mustRunDelay) {
        fn.apply(context, args)
        t_start = t_curr
      }
      else {
        // 定义新的定时器，一段时间后进行操作
        timer = setTimeout(function () {
          fn.apply(context, args)
        }, delay)
      }
    }
  }


// 缓存代理
// 缓存加法操作

// 主体
function add () {
  let arg = [].slice.call(arguments);
  return arg.reduce((a, b) => { a + b });
}

// 代理
let proxyAdd = (function () {
  let cache = [];

  return function () {
    let arg = [].slice.call(arguments).join(',');

    // 如果有，则直接从缓存返回
    if (cache[arg]) {
      return cache[arg];
    } else {
      let ret = add.apply(this, arguments);
      return ret;
    }
  };
})();

console.log(
  add(1, 2, 3, 4),
  add(1, 2, 3, 4),

  proxyAdd(10, 20, 30, 40),
  proxyAdd(10, 20, 30, 40)
); // 10 10 100 100
```

## 迭代器模式

迭代器模式是指提供一种方法 ***顺序访问*** 一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示

在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素

```js
// 实现 ES6 的 迭代器
function createIterator(items) {
    let i = 0;
    return {
        next: function() {
            let done = (i >= items.length);
            let value = !done ? items[i++] : undefined;
            return {
                done: done,
                value: value
            };
        }
    };
}
let iterator = createIterator([1, 2, 3]);
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next()); // "{ value: 2, done: false }"
console.log(iterator.next()); // "{ value: 3, done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
// 之后的所有调用
console.log(iterator.next()); // "{ value: undefined, done: true }"


// 迭代器 eg
function year2000() {
    let year = new Date().getFullYear();
    if (year <= 2000) {
        console.log('A');
    }
    return false;
}

function year2100() {
    let year = new Date().getFullYear();
    if (year >= 2100) {
        console.log('C');
    }
    return false;
}

function year() {
    let year = new Date().getFullYear();
    if (year > 2000 && year < 2100) {
        console.log('B');
    }
    return false;
}

function iteratorYear() {
    for (let i = 0; i < arguments.length; ++i) {
        let ret = arguments[i]();
        if (ret !== false) {
            return ret;
        }
    }
}

let manager = iteratorYear(year2000, year2100, year); // B
```

## 发布-订阅模式

也称作观察者模式

#### eg

小A在公司C完成了笔试及面试，小B也在公司C完成了笔试。他们焦急地等待结果，每隔半天就电话询问公司C，导致公司C很不耐烦。

一种解决办法是 AB直接把联系方式留给C，有结果的话C自然会通知AB

这里的询问属于显示 ***调用***，留给属于 ***订阅***，通知属于 ***发布***

#### 优缺点

***优***

一为时间上的解耦，二为对象之间的解耦

***缺***

- 创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销

- 弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解

```js
// 观察者
let observer = {
  // 订阅集合
  subscribes: [],
  // 订阅
  subscribe: function (type, fn) {
    if (!this.subscribes[type]) {
      this.subscribes[type] = [];
    }
    // 收集订阅者针对订阅内容的处理函数
    typeof fn === 'function' && this.subscribes[type].push(fn);
    // log 为 bool, 但这种表达式有啥意义？
  },

  // 发布  可能会携带一些信息发布出去
  publish: function () {
    let type = [].shift.call(arguments),
      fns = this.subscribes[type];
    console.log('发布  ', fns)
    // 不存在的订阅类型，以及订阅时未传入处理回调的
    if (!fns || !fns.length) {
      return;
    }
    // 挨个处理调用
    for (let i = 0; i < fns.length; ++i) {
      fns[i].apply(this, arguments);
    }
  },

  // 删除订阅
  remove: function (type, fn) {
    // 删除全部
    if (typeof type === 'undefined') {
      this.subscribes = [];
      return;
    }
    let fns = this.subscribes[type];
    // 不存在的订阅类型，以及订阅时未传入处理回调的
    if (!fns || !fns.length) {
      return;
    }
    if (typeof fn === 'undefined') {
      fns.length = 0;
      return;
    }
    // 挨个处理删除
    for (let i = 0; i < fns.length; ++i) {
      if (fns[i] === fn) {
        fns.splice(i, 1);
      }
    }
  }
};


// 订阅岗位列表
function jobListForA (jobs) {
  console.log('A', jobs);
}

function jobListForB (jobs) {
  console.log('B', jobs);
}

// A订阅了笔试成绩
observer.subscribe('job', jobListForA);
// B订阅了笔试成绩
observer.subscribe('job', jobListForB);


// A订阅了笔试成绩
observer.subscribe('examinationA', function (score) {
  console.log(score);
});

// B订阅了笔试成绩
observer.subscribe('examinationB', function (score) {
  console.log(score);
});

// A订阅了面试结果
observer.subscribe('interviewA', function (result) {
  console.log(result);
});

observer.publish('examinationA', 100); // 100
observer.publish('examinationB', 80); // 80
observer.publish('interviewA', '备用'); // 备用

observer.publish('job', ['前端', '后端', '测试']); // 输出A和B的岗位


// B取消订阅了笔试成绩
observer.remove('examinationB');
// A都取消订阅了岗位
observer.remove('job', jobListForA);

observer.publish('examinationB', 80); // 没有可匹配的订阅，无输出
observer.publish('job', ['前端', '后端', '测试']); // 输出B的岗位
```
